<html>
<div>Biological Ideal:<input type="color" id = "Biological" value = "#00FF00" size="7">
</div>
<div>Cultural Ideal: <input type="color" id = "Cultural" value = "#FF00FF" size="7"></div>
<div>Simulate: <input id = "ClickMe" type="button" value="clickme" onclick="simulate();"></div>
<canvas id = "gameCanvas" width = "1920" height = "600"></canvas>
<div id="Message">Waiting for start.</div>
<<<<<<< HEAD
<script src = "evolutionSim.js"></script>
=======
<script>
var aaaaa;
var canvas;
var canvasContext;
var mutationRate = 0.2;
var colorChangeRate = 0.003;
var colorMutationRate = 0.045;
var numGenerations = 10;
var numChanges = 300;
var numBots = 100;
var gray = new Array(127,127,127);
var bots = new Array(numBots);
var genBest = new Array(0);
var botRadius = 5;
var bioIdeal, cultureIdeal;
var DE, CY;
var width, height;
var gen, chng;
var Darwin = true;


window.onload = function() {
  canvas = document.getElementById("gameCanvas");
  canvasContext = canvas.getContext("2d");
  width = canvas.getAttribute("width");
  height = canvas.getAttribute("height");
}

function simulate() {
  document.getElementById("Message").innerHTML = "Simulating...";
  
  if(!DE) {
    clearInterval(DE);
    clearInterval(CY);
    console.log("clearing");
  }
  bioIdeal = h2r(document.getElementById("Biological").value);
  cultureIdeal = h2r(document.getElementById("Cultural").value);
  gen = 0; chng = 0;
  //Instantiate the bots
  for (i = 0; i < bots.length; i++) {
      let bot = new Bot();
      bots[i] = bot;
  }
  aaaaa = bots[1];
  //These two take care of the drawing and the simulation logics on separate timers for them to be independent of one another.
  DE =  setInterval(drawEverything, 1000/60);
  CY = setInterval(cycle, 1000/60);
}

//Use this function to run the simulation logics. (What needs to happen in the background so the logics are not tied to framerate)
function cycle() {
  //When the changes have reached the maximum, we need to stop the simulation for a bit.
  if (chng == numChanges -1) {
    document.getElementById("Message").innerHTML = "Generation " + gen+ " has finished its life, time for the fittest to have offspring!";
    clearInterval(CY);
    gen = gen + 1;
    chng = 0;
    //Sort the array of bots based on their fitness. 
    bots.sort(compare);
    var numReplic = Math.ceil(numBots * 0.25);
    var GenReproduce = new Array(numReplic);
    //Transfer the top 25 % to another array for reproduction. Stop drawing everything.
    clearInterval(DE);
    canvasContext.fillStyle = 'white';
    canvasContext.fillRect(0,0,canvas.width, canvas.height);
    //We also animate the best of that generation.
    for (i = 0; i < numReplic; i++) {
      GenReproduce[i] = bots[i];
      color = bots[i].getColor();
      drawCircle((i*20)+15,20,botRadius,color);
    }
    for (i = numReplic; i < bots.length ; i++) {
      drawCircle((i*20)+15,20,botRadius,[127,127,127]);
    }
    console.log(GenReproduce);
    //wait for 4 seconds to show the best from that generation before reproduction
    setTimeout( function() {
      console.log("Starting next sim");
      document.getElementById("Message").innerHTML = "Starting Generation " + gen + " 's simulation.";
      //Reproducing
      for (i = 0; i < numReplic; i++) {
        for (j = 0; j < 4; j++) {
          color = bots[i].getColor();
          GenReproduce[i].reproduce();
        }
      }
      //print new generation.
      for (i = 0; i < bots.length; i++) {
        drawCircle((i*20)+15,60,botRadius,color);
      }
      setTimeout(function(){
        //wait 2 seconds and then restart the simulation
        DE =  setInterval(drawEverything, 1000/60);
        CY = setInterval(cycle, 1000/60);
      }, 2000);
    }, 4000);
    


    
  } else {
    chng = chng + 1;
    acqChng();
  }
  
}

//Used to sort the bots array.
function compare(a,b) {
  const fitA = a.getFitness();
  const fitB = b.getFitness();

  let comparison = 0;

  if (fitA > fitB) {
    comparison = 1;
  } else if (fitA < fitB) {
    comparison = -1;
  }

  return comparison*-1;
}

function acqChng() {

  for(i = 0; i < bots.length; i++){
    bots[i].update();
  }
}
//Used to parse a #ffffff hex string into an [r,g,b] array
var h2r = function(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? [
        parseInt(result[1], 16),
        parseInt(result[2], 16),
        parseInt(result[3], 16)
    ] : null;
};  

//Parse an [rgb] array to a #ffffff string
var r2h = function(rgb) {
    return "#" + ((1 << 24) + (rgb[0] << 16) + (rgb[1] << 8) + rgb[2]).toString(16).slice(1);
};

// Interpolates two [r,g,b] colors and returns an [r,g,b] of the result
// Taken from the awesome ROT.js roguelike dev library at
// https://github.com/ondras/rot.js
//The functions related to the color are taken from https://codepen.io/njmcode/pen/axoyD/

var _interpolateColor = function(color1, color2, factor) {
  if (arguments.length < 3) { factor = 0.5; }
  var result = color1.slice();
  for (var i=0;i<3;i++) {
    result[i] = result[i] + factor*(color2[i]-color1[i]);
  }
  return result;
};
//function to convert from rgb to hsl
var rgb2hsl = function(color) {
  var r = color[0]/255;
  var g = color[1]/255;
  var b = color[2]/255;

  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h, s, l = (max + min) / 2;

  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = (l > 0.5 ? d / (2 - max - min) : d / (max + min));
    switch(max) {
      case r: h = (g - b) / d + (g < b ? 6 : 0); break;
      case g: h = (b - r) / d + 2; break;
      case b: h = (r - g) / d + 4; break;
    }
    h /= 6;
  }

  return [h, s, l];
};

//function to convert from hsl to rgb
var hsl2rgb = function(color) {
  var l = color[2];

  if (color[1] == 0) {
    l = Math.round(l*255);
    return [l, l, l];
  } else {
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var s = color[1];
    var q = (l < 0.5 ? l * (1 + s) : l + s - l * s);
    var p = 2 * l - q;
    var r = hue2rgb(p, q, color[0] + 1/3);
    var g = hue2rgb(p, q, color[0]);
    var b = hue2rgb(p, q, color[0] - 1/3);
    return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
  }
};

var _interpolateHSL = function(color1, color2, factor) {
  if (arguments.length < 3) { factor = 0.5; }
  var hsl1 = rgb2hsl(color1);
  var hsl2 = rgb2hsl(color2);
  for (var i=0;i<3;i++) {
    hsl1[i] += factor*(hsl2[i]-hsl1[i]);
  }
  return hsl2rgb(hsl1);
};

//Use this function to run the refresh rate and the graphic logic. (What gets printed every x seconds)
function drawEverything() {
    canvasContext.fillStyle = 'white';
    canvasContext.fillRect(0,0,canvas.width, canvas.height);
    //Draw bots on bot array 
    for(i = 0; i < bots.length; i++){
        var color = bots[i].getColor();
        drawCircle((i*20)+15,20,botRadius,color);
    }
}


//Circle with position x, y, radius r and whichever color. It has a black outline around it.
function drawCircle(x,y,r, color) {
    canvasContext.fillStyle = r2h(color);
    canvasContext.beginPath();
    canvasContext.arc(x,y,r*2,0,2*Math.PI);
    canvasContext.fill();
    canvasContext.beginPath();
    canvasContext.arc(x,y,r*2,0,2*Math.PI);
    canvasContext.stroke();
}


//This is just a class to keep track of the bots in case we add more functionalities to their behavior and changes later on.
class Bot {

    constructor(x = 200,y = 200,DNAcolor = false, bioInterpDNA = 0, ancestColor = false) {
      this.cInterpFitness = 0;
      //This variable keeps track of where in the interpolation we are each generation. We need to keep track of which color the earliest ancestor was to keep the interpolation straight
      this.bioInterpFitness = bioInterpDNA;
      this.ancestColor = ancestColor;
      if (DNAcolor != false) {
        //There is an ancestor creating this bot, take their fitness into account
        this.x = x;
        this.y = y;
        //Cultural fitness is calculated as the distance between the current color and the cultural ideal.
        
        if (Math.random() < mutationRate) {
          //This bot has mutated on birth!
          var mutationAmount = colorMutationRate * Math.random();
          if(Darwin) {
            //Interpolate between the oldest ancestor color and the new color. change the amount of biological interpolation DNA value.
            this.bioInterpFitness += mutationAmount;
            this.color = _interpolateColor(this.ancestColor, bioIdeal, this.bioInterpFitness);

          } else {
            //Interpolate between the recent ancestor color and the Biological ideal. Move the % the mutation amount is. This gives an exponential trend in the distance changed per mutation downwards each generation.
            this.color = _interpolateColor(this.DNAcolor, bioIdeal, mutationAmount);
          }
        }
      } else {
        //This bot was created without ancestors, we are GOD
        this.DNAcolor = getRandomColor();
        this.color = this.DNAcolor;
        
      } 
    }

    update() {
        var percent_change = (Math.random() * colorChangeRate);
        this.cInterpFitness = Math.min(this.cInterpFitness + percent_change, 1);
        this.color = _interpolateColor(this.color, cultureIdeal,  this.cInterpFitness);
    }

    getFitness() {
      this.fitness = calculateBioFitness(this.color, bioIdeal);
      return this.fitness;
    }

    reproduce() {
      let bot = new Bot(this.x, this.y, this.DNAcolor);
      bots.push(bot);
    }

    getColor() {
        return this.color;
    }
}

//Take the target color and it's relative positioning to the current colour to determine a fitness value
function calculateBioFitness(c1,c2){
  return Math.abs(eDistance(c1, c2));
}

//Take the target color and it's relative positioning to the current colour to determine a fitness value
function calculateCulturalFitness(c1,c2){
  return Math.abs(eDistance(c1, c2));
}

//Returns a random color in an RGB array Credit : Paolo Forgia Stack Overflow.
function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return h2r(color);
}

//Function returns the Euclidean distance between two colors (Given their RGB values as an array). 
function eDistance(p1, p2) {
  var d = 0;
  for (i = 0; i < p1.length; i++) {
    d += (p1[i] - p2[i])*(p1[i] - p2[i]);
  }
  return Math.sqrt(d);
}

</script>
>>>>>>> parent of f7d5c41... Interpolate RGB does not yet work. Need to fix that bug. Fixed the Random working with interpolation in HSL



</html>